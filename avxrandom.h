/* 
 * File:   avxrandom.h
 *
 * README:
 * This header file defines the AVX-512 versions of the operations drand48(), erand48(), Java.util.Random.nextDouble(),
 * as well as an unbiased method to get 64-bit integers in {0, 1, ... u-1}, where u is an upper bound, along with
 * the corresponding seeding methods. The generated sequences are identical to those generated by drand48, erand48,
 * and nextDouble. With our seeding methods, it is also applicable in a multi-core environment (e.g. using OpenMP)
 * where each core (each thread) generates different sub-sequences of the original sequence of random numbers.
 * 
 * Method summary:
 * _mm512_drand48_pd(s): returns in an AVX-512 vector 8 doubles that are subsequently generated by drand48/erand48
 * _mm512_nextdouble_pd(s): returns in an AVX-512 vector 8 doubles that are subsequently generated by Java.util.Random.nextDouble.
 * _mm512_nextlong_epi64(u,s): returns in an AVX-512 vector 8 int64 between 0 and u-1 (the upper boundary)
 * _mm512_seed_skip_epi64(v,j): the seed method for _mm512_drand48_pd and _mm512_sextlong_epi64; returns the initial state s
 * _mm512_java_seed_skip_epi64(v,j): the seed method for _mm512_nextdouble_pd; returns the initial state s
 * 
 * s (__m512i) is the state vector
 * v (int) is the seed value as it is used in srand48 and in the constructor in java.util.Random.
 * j (int64) is the number of random numbers that are implicitly skipped before the first number is generated
 * 
 * The following code example demonstrates its use:
 * srand48(25);
 * for(int i=0; i<n; i++){
 *     double h = drand48();
 *     // do something with h;
 * }
 * 
 * This is parallelized using OpenMP and AVX-512 as follows:
 * #pragma omp parallel for
 * for(int p=0; p<omp_get_max_threads(); p++){
 *     __m512i s = _mm512_seed_skip_epi64(25, p*n/8/omp_get_max_threads()*8);
 *     for(int i=p*n/8/omp_get_max_threads(); i<(p+1)*n/8/omp_get_max_threads(); i++){
 *         __m512d h = _mm512_drand48_pd(s);
 *         // do something with h;
 * }   }
 * 
 * If you use our methods for a publication please cite the following paper:
 * @InProceedings{BP2020,
 *   Title     = {Massively Parallel Random Number Generation},
 *   Author    = {Christian B\"(o)hm and Claudia Plant},
 *   Booktitle = {IEEE Int. Conf. on Big Data (BigData 2020},
 *   Year      = {2020}}
 */

#ifndef AVXRANDOM_H
#define AVXRANDOM_H

#include <lzcntintrin.h>
#include <immintrin.h>

unsigned long long avxDrand48SeedMultipliers[] __attribute__ ((aligned (64))) = 
    {21400953444813ull, 182230907513417ull, 58660064646933ull, 241509987545585ull, 21586261248413ull, 254681119335897ull, 246154705703781ull, 1ull};
unsigned long long avxDrand48SeedIncrements[] __attribute__ ((aligned (64))) = 
    {252010051309667ull, 205945562491954ull, 240160708164949ull, 40996489149244ull, 164331561754775ull, 120305458776662ull, 107048004364969ull, 0ull};
unsigned long long avxDrand48S4DMultipliers[] __attribute__ ((aligned (64))) = 
    {41443959128365ull,  64657241701749ull,  161586145003261ull,  170252040060869ull,  21400953444813ull,  58660064646933ull,  21586261248413ull,  246154705703781ull};
unsigned long long avxDrand48S4DIncrements[] __attribute__ ((aligned (64))) = 
    {22770854645179ull,  167985936766573ull,  21987048151919ull,  158763513494849ull,  252010051309667ull,  240160708164949ull,  164331561754775ull,  107048004364969ull};

inline unsigned long long skiprnd_tz (unsigned long long s, unsigned long long n){
    static const unsigned long long a[] = {
        25214903917ull, 205749139540585ull, 55986898099985ull, 128954768138017ull, 120681609298497ull, 275731715003521ull, 188525651585281ull,
        180528750645761ull, 87549693371393ull, 163808472418305ull, 204907653009409ull, 204610643763201ull, 43875330310145ull, 18348552519681ull, 198893323747329ull,
        61409103839233ull, 184682916610049ull, 53874715525121ull, 253159843823617ull, 243536408608769ull, 280364631195649ull, 15371495014401ull, 101111734206465ull,
        202223468412929ull, 122971960115201ull, 245943920230401ull, 210412863750145ull, 139350750789633ull, 278701501579265ull, 275928026447873ull, 270381076185089ull,
        259287175659521ull, 237099374608385ull, 192723772506113ull, 103972568301569ull, 207945136603137ull, 134415296495617ull, 268830592991233ull, 256186209271809ull,
        230897441832961ull, 180319906955265ull, 79164837199873ull, 158329674399745ull, 35184372088833ull, 70368744177665ull, 140737488355329ull, 1ull
    };
    static const unsigned long long c[] = {
        11ull, 277363943098ull, 49720483695876ull, 137139456763464ull, 14307911880080ull, 33313044635424ull, 272110203194944ull,
        119575439531136ull, 184341046147328ull, 173830792901120ull, 188734207353856ull, 252559361427456ull, 116052147802112ull, 123345053360128ull, 132710533054464ull,
        126162120245248ull, 258238410457088ull, 258658524069888ull, 48993814183936ull, 195019529519104ull, 215216710221824ull, 12619001888768ull, 42830189821952ull,
        156029123821568ull, 30583270932480ull, 61166541864960ull, 122333083729920ull, 244666167459840ull, 207857358209024ull, 134239739707392ull, 268479479414784ull,
        255483982118912ull, 229492987527168ull, 177510998343680ull, 73547019976704ull, 147094039953408ull, 12713103196160ull, 25426206392320ull, 50852412784640ull,
        101704825569280ull, 203409651138560ull, 125344325566464ull, 250688651132928ull, 219902325555200ull, 158329674399744ull, 35184372088832ull, 70368744177664ull        
    };
    while(n){
        int i = _tzcnt_u64(n);
        s = (s * a[i] + c[i]) ;
        n ^= 1ull << i;
    }
    return s & 281474976710655ull;
}


// this is a helper define for the linear operation in the LCG: It computes (s*a+c) MOD 2^48
#define _mm512_maa_epi64(s,a,c) (_mm512_and_epi64(_mm512_add_epi64(_mm512_mullox_epi64((s), (a)), (c)), _mm512_set1_epi64(281474976710655ull)))

#define _mm512_drand48_pd(s) (_mm512_sub_pd(_mm512_castsi512_pd(_mm512_or_epi64(_mm512_castpd_si512(_mm512_set1_pd(16.)), \
        (s) = _mm512_maa_epi64((s), _mm512_set1_epi64(128954768138017ull), _mm512_set1_epi64(137139456763464ull)))),\
        _mm512_set1_pd(16.) ) )

#define _mm512_nextdouble_pd(s) (_mm512_add_pd(_mm512_sub_pd(_mm512_castsi512_pd(\
        _mm512_or_epi64(_mm512_castpd_si512(_mm512_set1_pd(16.)), \
        _mm512_and_epi64(_mm512_set1_epi64(281474972516352), (s) = _mm512_add_epi64(_mm512_mullox_epi64((s), \
        _mm512_set1_epi64(120681609298497ull)), _mm512_set1_epi64(14307911880080ull)))\
        )), _mm512_set1_pd(16.0000002384185791015625)), _mm512_castsi512_pd(_mm512_or_epi64(\
        _mm512_set1_epi64(0x3e90000000000000ull), \
        _mm512_and_epi64(_mm512_set1_epi64(281474974613504), _mm512_add_epi64(_mm512_mullox_epi64((s), \
        _mm512_set1_epi64(262331189124013ull)),\
        _mm512_set1_epi64(215905707320923ull)))))))

#define _mm512_epi64_to_pd(x) (_mm512_sub_pd(_mm512_castsi512_pd(_mm512_or_epi64((x), _mm512_set1_epi64(0x4330000000000000ull))), _mm512_castsi512_pd(_mm512_set1_epi64(0x4330000000000000ull))))

#define _mm512_trunc_pd_to_epi64(x) (_mm512_and_epi64(_mm512_set1_epi64(0xFFFFFFFFFFFFull), _mm512_castpd_si512(_mm512_max_pd(_mm512_set1_pd(4503599627370496.), _mm512_add_pd((x),_mm512_set1_pd(4503599627370495.5))))))

#define _mm512_nextlong_epi64(x,s) (_mm512_trunc_pd_to_epi64(_mm512_mul_pd(_mm512_epi64_to_pd(x),_mm512_drand48_pd(s))))

#define _mm512_seed_skip_epi64(v,j) (_mm512_maa_epi64(_mm512_set1_epi64(skiprnd_tz(((unsigned long long)(v)<<16)|13070ull, (j))), _mm512_load_si512(avxDrand48SeedMultipliers), _mm512_load_si512(avxDrand48SeedIncrements)))

#define _mm512_java_seed_skip_epi64(v,j) (_mm512_maa_epi64(_mm512_set1_epi64(skiprnd_tz((unsigned long long)(v)^25214903917ull, (j)*2)), _mm512_load_si512(avxDrand48S4DMultipliers), _mm512_load_si512(avxDrand48S4DIncrements)))

#endif /* AVXRANDOM_H */
